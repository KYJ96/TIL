# C

## 1. #include 

> * C# 에서는 using 지시문과 비슷하다.
> * #include 는 전처리기 지시문 중 하나이다. 
> * 전처리기(preprocessor)란?	
>   * 프로그램을 컴파일할 때 컴파일 직전에 실행되는 별도의 프로그램 
>   * 컴파일러가 실행되기 직전에 단순히 텍스트를 조작하는 치환 역할
>   * 디버깅에도 도움을 주며, 헤더 파일의 중복 포함도 방지해주는 기능을 가진다.
> * 기본적인 지시문이 #include <stdio.h> 이다.
>
> * #include 는 전처리기 지시문 중 하나이다. 



## 2. main(void) 함수

> ```c
> int main(void)
> {
>     // 실행코드
>     return 0;
> }
> ```
>
> * 프로그램의 진입점
> * int main(void) 부분을 머리, { }```중괄호``` 부분을 몸통이라고 한다.
> * 머리 (함수 원형(```function prototype```)) : 함수의 이름과 필요한 데이터 등을 표시.
> * 함수에서 실행할 일들은 몸통의 {}```중괄호``` 안에 작성.
> * 몸통의 마지막에는 return 0; 을 넣어 프로그램을 종료.
>   * 0 : 프로그램에 문제 없었다는 의미



## 3. printf()함수

>화면에 데이터를 출력할 때 사용.
>
>printf  (``print formatted``) : 서식에 맞게 출력.
>
>printf 함수로 출력할 때 행을 바꾸려면 제어 문자를 사용, 제어 문자는 ``\n`` 이다.
>
>
>
>> * ```\n(개행,new line)``` 
>>
>>   : 다음 줄로 이동
>>
>> * ```\b(백스페이스,backspace)```
>>
>>   : 한 칸 왼쪽으로 이동
>>
>> * ```\r(캐리지 리턴, carriage return)```
>>
>>   : 맨 앞으로 이동
>>
>> * ```\a(알럿 경보, alert)```
>>
>>   : 벨소리



## 4. 주석 (Comment)

> 프로그램에 있어 내용을 메모하는 목적으로 쓰임.
>
> /* */ 만 지원(C89에서는)
>
> C, C++, Java, JavaScript의 경우는 한 줄 주석은 //, 여러 줄 주석은 /* */ 이다.



### - C언어 주석의 형태

>**예제**
>
>```C  
>/* Hello World라는 문구를 출력 시켜주는
>프로그램이다. */
>#include <stdio.h>
>int main(void)
>{
>    printf("Hello World \n"); //Hello World라는 문구를 출력한다.
>	
>    return 0;
>}
>```



# C언어의 기본 문법 1

>* C는 절차적 언어(절차적 언어는 이해하기 쉬움)
> * 메뉴얼에 적혀 있는 내용을 순서대로 따라하는 느낌
>* 클래스 X
> * 함수
> * 모두 전역(global) 함수
> * 기본적으로 어디에서나 호출 가능
> * 변수
>  * 함수 밖 선언 : 전역 변수
> * 함수 안 선언 : 지역(local) 변수



## 1. 자료형, unsigned와 signed

>* 정수형을 양수 전용으로 쓰고 싶을 때는 unsigned를 사용한다.
>
> * unsigned 자료형을 사용할 때는 출력 시 변환 문자 사용에 **주의!!**
>   
>   * unsigned 자료형은 항상 양수만 저장하고 %u로 출력하기를 권장.
>   
>* signed는 C/C++ 프로그램 언어에서 정수형 변수 중 부호를 갖는 변수를 선언한다. 
>
>* 정수형 중 음수는 2의 보수 체계를 사용, 이 키워드에 의해 부호를 사용할 수 있도록 변수 선언할 수 있다. 
>
> * **But**, 정수형의 변수에서 unsigned가 없으면 음수를 사용할 수 있는 부호를 갖는 정수형이 된다.   
>
>   따라서 프로그램에서는 이 키워드는 많이 사용은 하지 않는다.



## 2. char 형

> **char(character)** : **최소 8비트**인 정수형 처리 변수, 
>
> 부호형 변수 :  -128~127까지의 숫자를 취급. 
>
> >   **범위**
> >
> > * 부호 없는 경우(unsigned) : 0~255
> > * 보통 부호 있는 경우(signed) : -128~127    (**BUT**, 안전한 포팅을 위해선 -128이 아닌 -127 사용.)
> > * 부호(unsigned/signed)를 생략할 경우 : signed
> >
> > ```c
> > char signed_char = -1;
> > ```
>
> 부호가 있는 정수형 : 2의 보수 체계를 사용하여 +와 -로 나누어 숫자를 표현.  
>
> 아스키 코드 값은 기본적으로 8비트 이므로 이것은 8비트 정수형의 부분집합일 뿐이다. 따라서 문자 만이 아니라 8비트 정수형 연산도 가능하다. 
>
> ex ) 'A'를 'a'로 바꾸려면 정수형 연산으로 가능하다. 이때 역시 ALU을 통한 정수형 연산이 기계어 코드에 의해 계산 된다. 
>
> * **표준은 8비트 이상이라고만 정의.**
>
> **char** 가 몇 비트인지 찾는 방법
>
> ```c
> # include <limits.h>
> 
> int main(void)
> {
> 	char char_size = CHAR_BIT;
>     return 0;
> }
> ```
>
> ```<limits.h>```헤더를 include 한 뒤, ```CHAR_BIT```를 보면 몇 비트인지 확인 가능.
>
> **단**, 8비트 정수형으로 쓸 때 반드시 char 앞에 signed나 unsigned를 작성하는 게 좋음.



## 3. short형

> * 기본 정수형보다 짧음.
>
> * 메모리를 적게 쓰기 위해 사용.
> * **BUT**, int 대신 short를 사용할 경우 성능 느려질 가능성 有
>   1. 크기  : 표준에 따르면 **최소 16비트**, int의 크기 이상인 정수형
>   2. 범위 (포팅 문제 없는 값의 범위)
>      * 부호 없는 경우(unsigned) : 0~65535
>      * 부호 있는 경우(signed) : -32768~32767



## 4. int형

> int : 정수(integer)
>
> C언어의 타입 정의에 int형은 **"CPU의 레지스터와 동일한 크기를 가지는 타입"**으로 정의되어 있다.
>
> ```레지스터란?``` :  CPU내의 임시 기억 장소이며, 레지스터의 크기에 따라 CPU의 비트수를 정의한다.
>
> **즉, 레지스터가 16비트 : 16비트 컴퓨터 **
>
> ​                          **32비트 : 32비트 컴퓨터**
>
> * 즉,  int형은 CPU가 가장 효율적으로 다룰 수 있는 정수형으로 정의되어 있다.
>   *  그래서 int형의 실제 크기는 플랫폼에 따라 달라진다.
>   * **32비트 운영체제**에서 int 는 **32비트**, **64비트 운영체제**에서 int형이 64비트(8바이트)가 될 것이다.
>
> * 특별한 경우가 아니면 정수형은 int를 사용
>
>   * int형은 연산의 기본 단위, 컴퓨터에서 가장 빠르게 연산.
>
> * 각 자료형의 크기는 컴파일러나 버전에 따라 다를 수 있으나 다음 기준에 따라 구현된다.
>
>   ```c
>   char <= short <= int <= long <= long long
>   ```
>
> * **리터럴(literal)** : 데이터 그 자체를 뜻함. (변수의 값이 변하지 않는 데이터**(메모리 위치 안의 값 )**)
>
>   * 'u' or 'U' : 부호 없는(unsigned) 수를 표현하는 접미사
>     * 부호 있는 수의 최댓값보다 큰 값을 unsigned int에 대입할 경우 'u' or 'U' 를 붙인다.
>     * 안 붙이면 경고 발생



## 5. long형

> * c언어에서 int와 long은 크기나 부호 여부가 동일
> * 따라서 표현할 수 있는 수의 범위도 완전히 동일한 것처럼 보임.
>   * **BUT**, 엄밀히 말하면 다른 타입이다.  
> * ```long형```은 그 크기가 4바이트로 고정, 어떤 플랫폼에서나 4바이트. 
> * **차이점** : int와 long이 동일한 크기를 가지는 것은 32비트 플랫폼에서 뿐이다.
> * 16비트에서는 다른 타입이고 64비트에서도 달라질 것.
> * long의 리터럴
>   * 'l' or 'L' : long 을 의미하는 접미사
>   * 'u' or 'U' : 부호 없는 수를 표현하는 접미사
>   * 두 접미사를 같이 쓸 수 있음 : unsigned long 이라는 의미가 됨
> * C 표준에 따른 long형의 크기 : 최소 32비트, int 이상



## 6. float형 

> * float는 **IEEE 754 Single**(32비트)
> * 표준에 따른 C의 float은 IEEE 754일수도 있고, 아닐 수도 있다.
> * 크기 : char (8비트) 이상이기만 하면 됨.
> * **unsigned**형 X
> * 표준 상관 X, 보통 안전하게 생각해도 되는 것
>   * 크기 : 32비트
>   * 범위 : IEEE 754 Single과 동일
> * 관련 헤더 파일 : ```float.h``` 



## 7. double형

>* double : IEEE 754 Double(64비트) **[컴파일러 구현에 따라 다름, IEEE 754 Double이라는 보장 X]**
>* 크기 : float 이상이면 됨.
>* **unsigned**형 X
>* 표준 상관 X, 보통 안전하게 생각해도 되는 것
>  * 크기 : 64비트
>  * 범위 : IEEE 754 Double과 동일
>* 관련 헤더 파일 : ```float.h``` 



### - long double

> * **생각보다 잘 안 쓰임!!**
>
> double보다 정밀도 ↑
>
> **double 이상의 크기**면 됨
>
> **unsigned**형 X
>
> 관련 헤더 파일 : ```float.h``` 
>



## 8. 열거형(enum)

> * 열거형은 여러 문자열을 하나의 그룹으로 만들어 놓고, 각각 번호를 붙여서 그 키워드가 곧 값이 되는 상수와도 비슷한 존재



## 9. 변수 선언

> * 변수 선언은 반드시 블럭의 시작에서 한다.
> * 코드 중간에 사용하는 변수 → 블록 시작에서 선언만 하고 뒤에 대입.



## 10. 연산자 (C에서 새로 만나는 연산자)

> * sizeof()
> * 역 참조 연산자 * 
> * 주소 연산자 &
> * 구조체와 공용체 멤버 접근자 .과 →



### 10-1 sizeof() 연산자

>* 피연산자의 크기를 바이트로 반환해주는 연산자
>* 실행 중이 아닌 컴파일 도중에 크기를 찾음 (stack쪽에서 정확하게 배움.)
>* char형을 넣으면 반드시 1이 반환.
>* sizeof()연산자가 반환하는 값은 부호 없는 정수형의 상수로 **size_t**형



### 10-2 size_t

> * 부호 없는 정수형, But 실제 데이터형은 아님.
> * 단, 배열을 만들면 그 배열의 바이트 크기를 얻을 수 있다고 명시.
> * _t는 typedef를 했다는 **hint!!**
> * C99 표준에서 확실히 최소 16비트를 요구.
> * 보통은 unsigned int를 사용.
> * 용도 : 어떤 것의 크기를 나타내기 위해 사용.
> * size_t를 쓰기에 적합한 경우: **배열의 색인으로 사용할 때.**
> * ex)  반복문이나 배열에 접근할 때 사용
>   * 반복문의 카운터 변수에 음수 필요가 없을 경우
>   * 배열의 경우 길이가 음수가 될 수 없으니까......
> * 배열의 경우, 함수 인자로 받을 경우 다른 결과 나옴.



### 10-3 구조체/공용체 멤버 접근자

> * . 연산자
>   * C에는 클래스 X, 따라서 함수 호출에 쓸 수 없다.
>   * 구조체,공용체 있으니 그들의 멤버변수에 접근할 때 사용
> * → 연산자
>   * 2개의 연산자 ' . ' 와 ' * '를 합친 것
>   * 구조체,공용체 있으니 그들의 멤버변수에 접근할 때 사용



### 10-4 비교 연산자,논리 연산자,조건 연산자

>* 비교 연산자
>
>  * ==
>  * !=
>  * < >
>  * <=
>  * '  >=   ' (' '한 이유는 >= 하면 세로줄이 쳐지기 때문에....)
>
>* 논리 연산자
>
>  * &&
>  * ||
>  * !
>
>* 조건(conditional) 연산자
>
>  * 삼항 연산자(ternary operator)라 불림
>
>    ```c
>    int num1 = 13;
>    int num2 = 67;
>    int min  = num1 < num2 ? num1 : num2;
>    ```



### 10-5 switch/case문

> * case에 사용 가능한 데이터형 : int, char ,enum 만 가능 (정수형)
> * 의도를 가지고 **'break'** 를 사용하지 않을 경우
>   * /* intentional fallthrough */  주석을 반드시 적는다!!
> * case 레이블은 반드시 상수만!



### 10-6 for문, while문

> * for문
>   * for문의 초기화 코드에 size_t=0 못 씀. 
>   * for(size_t=0;i<9;++i) → 컴파일 오류!!
> * while문은 C#에서 while문과 동일하다.



# C언어의 기본 문법 2, 빌드 단계



## 1. 함수

> * C의 함수 선언은 C#과 거의 동일
> * 접근 제어자가 없다.
> * 기본적으로 모두 전역(global)함수
> * C의 함수는 어디서든 호출할 수 있다.
>   * 다만, 이걸 제한할 수 있는 키워드가 있다.
> * C는 언제나 위에서 아래로 코드를 읽음.
> * 컴파일이 오류나지 않기 위한 **Solution~~**
>   * 호출 전에 함수의 정의를 위치시키면 아무 문제 없다.





### 1-1 함수 선언(function declaration)

> * 함수의 구현체 없이 함수 원형만 선언해 주는 것
>
> > **함수 원형**은 아래의 번호들을 명시한다.
> >
> > 1. 함수의 이름
> > 2. 반환형
> > 3. 매개변수들의 자료형
>
> 함수 선언은 언제나 하는 것이 좋다
>
> * C99 표준부터는 int 가정을 하지 않는다.
>   * 그러나 어떤 컴파일러는 경고만, 컴파일은 허용 할 수도 있다.
>   * 모든 컴파일러가 그렇단 보장이 없기 때문에 반드시 선언.





### 1-2 함수 매개변수 평가 순서, 피연산자 평가 순서

> * 함수 매개변수의 평가 순서는 지정되어 있지 않음.
> * 누가 먼저 호출되는지는 컴파일러에 따라 다르다.



> * 명시되지 않은 피연산자 평가 순서에서
>   * 한 줄에 있는 함수 호출 순서에 의존해서 코드를 작성하지 말자!!
>   * 해결 방법 : 두 함수를 두 줄에 따로 호출.
> * 기본적으로 한 줄에서 동일한 변수를 여러 번 바꾸면 위험하다.
>   * 함수 매개변수의 평가 순서는 컴파일러마다 다를 수 있다
>   * 한 함수의 매개변수들이 동일한 변수를 수정할 경우, 결과가 정의되지 않음. (undefined behavior)



### 1-3 연산자 우선순위와 평가 순서 

> 연산자 우선순위와 평가 순서는 **서로 아무 연관이 없음**.
>
> ```c
> int i=0;
> int j=0;
> int k=0;
> 
> if(++i || ++j && ++k)
> {
>     printf("true\n");
> }
> printf("%d %d %d\n",i,j,k);
> ```
>
> 
>
> * 연산자의 우선 순위에 따라 && 부분을 묶는 것 맞다.
>
>   * BUT, 왼쪽부터 차례대로 연산한다.
>
>   ++i 를 먼저 연산하면 1 참이 된다.
>
> O or O 는 둘 중에 하나만 참이 되면 되기 때문에 이미 ++i가 참이므로 오른쪽 피연산자 검사할 필요가 없다. 
>
> 이러한 경우를 ``short circuit`` 평가라고 한다. 



> 위의 코드와 비슷하게 i 부분을 i++로 변경한다면,
>
> 먼저 연산하면 0 (거짓)이 되기 때문에 오른쪽 연산을 하게 된다.
>
> 뒷 부분 ++j && ++k 부분을 연산하면 1&&1이므로 참이 된다.
>
> 거짓 or 참을 연산하게 되면 참이 되므로 최종적으로 i=1,j=1,k=1이 된다.



> 한 줄에 있는 피연산자들은 기본적으로 **평가 순서가 보장 안된다**고 생각하면 된다!!



### 1-4 범위 (scope)

> * 4가지 범위
>   * 블록 범위 
>   * 파일 범위
>   * 함수 범위
>   * 함수 선언 범위
>
> * 파일 범위
>   * 어떤 블록이나 매개변수 목록에도 안 속하고 파일 안에 있는 것
> * 함수 범위
>   * ex) 레이블(label)
>   * goto 문에서 사용.
> * 함수 선언 범위
>   * 함수 선언의 매개변수 목록에 있는 것 → 그 목록 안에서 접근 가능.
>   * 많이 쓸 일은 없다.



### 1-5 const 키워드

> * 이름 달린 상수를 만들어 주기 좋다.
> * 정말 값 변경이 필요한 변수에만 const를 생략.
> * In principle, 언어의 기본동작이 바뀌어야 함.
>   * 아무것도 안 붙이면 const



### 1-6 goto 문

> ```c
> goto <label_name>;
> ...
> <label_name>:    
> ```
>
> * ``goto``를 쓰면 같은 함수 내에 있는 레이블(label)로 점프.
> * goto 문은 악마인가?
>   * 코드가 꼬여 있어서 스파게티 코드라고 불린다.
>   * goto 없이 안쪽 for문에서 탈출하려면 많은 if문을 사용하게 됨.
> * 중간에 에러가 나면 이미 수행한 작업을 되돌리는데 편함.
> * goto문은 언제나 전방 (아래쪽)으로만 점프할 것
>   * 후방 (위)으로 점프하면 스파게티처럼 꼬인다.
> * 내포된 루프에서 빠져나올 때 자유롭게 쓸 것.
> * 한 함수 안에 있는 여러 개의 조건문이 공통된 코드를 실행해야 할 때도 써도 됨.
>   * ex) 함수 마지막에 성공/오류 조건 처리
> * 가독성을 위해 goto문은 언제나 아래쪽에 위치한 레이블로만 점프.



## 2. 배열

### 2-1 스택 메모리

> * 스택 메모리의 크기 : 프로그램 빌드 시에 결정됨.
>
> * 스택 메모리의 위치 : 실행 시에 결정됨.
>
> * 개념 : 함수가 호출될 때마다 그 함수에서 필요한 공간을 스택에서 떼어줬다가,
>
>   ​		   그 함수가 반환하면 그냥 흔들어 지워버리는 개념 
>
>   * 실제로 지우지는 않는다.
>
> * new로 만든 데이터 : 힙(heap) 메모리에 할당됨
>
>   * 이러한 경우 메모리에 구멍이 슝슝 뚫릴 수 있음.

