# C

## 1. #include 

> * C# 에서는 using 지시문과 비슷하다.
> * #include 는 전처리기 지시문 중 하나이다. 
> * 전처리기(preprocessor)란?	
>   * 프로그램을 컴파일할 때 컴파일 직전에 실행되는 별도의 프로그램 
>   * 컴파일러가 실행되기 직전에 단순히 텍스트를 조작하는 치환 역할
>   * 디버깅에도 도움을 주며, 헤더 파일의 중복 포함도 방지해주는 기능을 가진다.
> * 기본적인 지시문이 #include <stdio.h> 이다.
>
> * #include 는 전처리기 지시문 중 하나이다. 



## 2. main(void) 함수

> ```c
> int main(void)
> {
>     // 실행코드
>     return 0;
> }
> ```
>
> * 프로그램의 진입점
> * int main(void) 부분을 머리, { }```중괄호``` 부분을 몸통이라고 한다.
> * 머리 (함수 원형(```function prototype```)) : 함수의 이름과 필요한 데이터 등을 표시.
> * 함수에서 실행할 일들은 몸통의 {}```중괄호``` 안에 작성.
> * 몸통의 마지막에는 return 0; 을 넣어 프로그램을 종료.
>   * 0 : 프로그램에 문제 없었다는 의미



## 3. printf()함수

>화면에 데이터를 출력할 때 사용.
>
>printf  (``print formatted``) : 서식에 맞게 출력.
>
>printf 함수로 출력할 때 행을 바꾸려면 제어 문자를 사용, 제어 문자는 ``\n`` 이다.
>
>
>
>> * ```\n(개행,new line)``` 
>>
>>   : 다음 줄로 이동
>>
>> * ```\b(백스페이스,backspace)```
>>
>>   : 한 칸 왼쪽으로 이동
>>
>> * ```\r(캐리지 리턴, carriage return)```
>>
>>   : 맨 앞으로 이동
>>
>> * ```\a(알럿 경보, alert)```
>>
>>   : 벨소리



## 4. 주석 (Comment)

> 프로그램에 있어 내용을 메모하는 목적으로 쓰임.
>
> /* */ 만 지원(C89에서는)
>
> C, C++, Java, JavaScript의 경우는 한 줄 주석은 //, 여러 줄 주석은 /* */ 이다.



### - C언어 주석의 형태

>**예제**
>
>```C  
>/* Hello World라는 문구를 출력 시켜주는
>프로그램이다. */
>#include <stdio.h>
>int main(void)
>{
>    printf("Hello World \n"); //Hello World라는 문구를 출력한다.
>	
>    return 0;
>}
>```



# C언어의 기본 문법 1

>* C는 절차적 언어(절차적 언어는 이해하기 쉬움)
> * 메뉴얼에 적혀 있는 내용을 순서대로 따라하는 느낌
>* 클래스 X
> * 함수
> * 모두 전역(global) 함수
> * 기본적으로 어디에서나 호출 가능
> * 변수
>  * 함수 밖 선언 : 전역 변수
> * 함수 안 선언 : 지역(local) 변수



## 1. 자료형, unsigned와 signed

>* 정수형을 양수 전용으로 쓰고 싶을 때는 unsigned를 사용한다.
>
> * unsigned 자료형을 사용할 때는 출력 시 변환 문자 사용에 **주의!!**
>   
>   * unsigned 자료형은 항상 양수만 저장하고 %u로 출력하기를 권장.
>   
>* signed는 C/C++ 프로그램 언어에서 정수형 변수 중 부호를 갖는 변수를 선언한다. 
>
>* 정수형 중 음수는 2의 보수 체계를 사용, 이 키워드에 의해 부호를 사용할 수 있도록 변수 선언할 수 있다. 
>
> * **But**, 정수형의 변수에서 unsigned가 없으면 음수를 사용할 수 있는 부호를 갖는 정수형이 된다.   
>
>   따라서 프로그램에서는 이 키워드는 많이 사용은 하지 않는다.



## 2. char 형

> **char(character)** : **최소 8비트**인 정수형 처리 변수, 
>
> 부호형 변수 :  -128~127까지의 숫자를 취급. 
>
> >   **범위**
> >
> > * 부호 없는 경우(unsigned) : 0~255
> > * 보통 부호 있는 경우(signed) : -128~127    (**BUT**, 안전한 포팅을 위해선 -128이 아닌 -127 사용.)
> > * 부호(unsigned/signed)를 생략할 경우 : signed
> >
> > ```c
> > char signed_char = -1;
> > ```
>
> 부호가 있는 정수형 : 2의 보수 체계를 사용하여 +와 -로 나누어 숫자를 표현.  
>
> 아스키 코드 값은 기본적으로 8비트 이므로 이것은 8비트 정수형의 부분집합일 뿐이다. 따라서 문자 만이 아니라 8비트 정수형 연산도 가능하다. 
>
> ex ) 'A'를 'a'로 바꾸려면 정수형 연산으로 가능하다. 이때 역시 ALU을 통한 정수형 연산이 기계어 코드에 의해 계산 된다. 
>
> * **표준은 8비트 이상이라고만 정의.**
>
> **char** 가 몇 비트인지 찾는 방법
>
> ```c
> # include <limits.h>
> 
> int main(void)
> {
> 	char char_size = CHAR_BIT;
>     return 0;
> }
> ```
>
> ```<limits.h>```헤더를 include 한 뒤, ```CHAR_BIT```를 보면 몇 비트인지 확인 가능.
>
> **단**, 8비트 정수형으로 쓸 때 반드시 char 앞에 signed나 unsigned를 작성하는 게 좋음.



## 3. short형

> * 기본 정수형보다 짧음.
>
> * 메모리를 적게 쓰기 위해 사용.
> * **BUT**, int 대신 short를 사용할 경우 성능 느려질 가능성 有
>   1. 크기  : 표준에 따르면 **최소 16비트**, int의 크기 이상인 정수형
>   2. 범위 (포팅 문제 없는 값의 범위)
>      * 부호 없는 경우(unsigned) : 0~65535
>      * 부호 있는 경우(signed) : -32768~32767



## 4. int형

> int : 정수(integer)
>
> C언어의 타입 정의에 int형은 **"CPU의 레지스터와 동일한 크기를 가지는 타입"**으로 정의되어 있다.
>
> ```레지스터란?``` :  CPU내의 임시 기억 장소이며, 레지스터의 크기에 따라 CPU의 비트수를 정의한다.
>
> **즉, 레지스터가 16비트 : 16비트 컴퓨터 **
>
> ​                          **32비트 : 32비트 컴퓨터**
>
> * 즉,  int형은 CPU가 가장 효율적으로 다룰 수 있는 정수형으로 정의되어 있다.
>   *  그래서 int형의 실제 크기는 플랫폼에 따라 달라진다.
>   * **32비트 운영체제**에서 int 는 **32비트**, **64비트 운영체제**에서 int형이 64비트(8바이트)가 될 것이다.
>
> * 특별한 경우가 아니면 정수형은 int를 사용
>
>   * int형은 연산의 기본 단위, 컴퓨터에서 가장 빠르게 연산.
>
> * 각 자료형의 크기는 컴파일러나 버전에 따라 다를 수 있으나 다음 기준에 따라 구현된다.
>
>   ```c
>   char <= short <= int <= long <= long long
>   ```
>
> * **리터럴(literal)** : 데이터 그 자체를 뜻함. (변수의 값이 변하지 않는 데이터**(메모리 위치 안의 값 )**)
>
>   * 'u' or 'U' : 부호 없는(unsigned) 수를 표현하는 접미사
>     * 부호 있는 수의 최댓값보다 큰 값을 unsigned int에 대입할 경우 'u' or 'U' 를 붙인다.
>     * 안 붙이면 경고 발생



## 5. long형

> * c언어에서 int와 long은 크기나 부호 여부가 동일
> * 따라서 표현할 수 있는 수의 범위도 완전히 동일한 것처럼 보임.
>   * **BUT**, 엄밀히 말하면 다른 타입이다.  
> * ```long형```은 그 크기가 4바이트로 고정, 어떤 플랫폼에서나 4바이트. 
> * **차이점** : int와 long이 동일한 크기를 가지는 것은 32비트 플랫폼에서 뿐이다.
> * 16비트에서는 다른 타입이고 64비트에서도 달라질 것.
> * long의 리터럴
>   * 'l' or 'L' : long 을 의미하는 접미사
>   * 'u' or 'U' : 부호 없는 수를 표현하는 접미사
>   * 두 접미사를 같이 쓸 수 있음 : unsigned long 이라는 의미가 됨
> * C 표준에 따른 long형의 크기 : 최소 32비트, int 이상



## 6. float형 

> * float는 **IEEE 754 Single**(32비트)
> * 표준에 따른 C의 float은 IEEE 754일수도 있고, 아닐 수도 있다.
> * 크기 : char (8비트) 이상이기만 하면 됨.
> * **unsigned**형 X
> * 표준 상관 X, 보통 안전하게 생각해도 되는 것
>   * 크기 : 32비트
>   * 범위 : IEEE 754 Single과 동일
> * 관련 헤더 파일 : ```float.h``` 



## 7. double형

>* double : IEEE 754 Double(64비트) **[컴파일러 구현에 따라 다름, IEEE 754 Double이라는 보장 X]**
>* 크기 : float 이상이면 됨.
>* **unsigned**형 X
>* 표준 상관 X, 보통 안전하게 생각해도 되는 것
>  * 크기 : 64비트
>  * 범위 : IEEE 754 Double과 동일
>* 관련 헤더 파일 : ```float.h``` 



### - long double

> * **생각보다 잘 안 쓰임!!**
>
> double보다 정밀도 ↑
>
> **double 이상의 크기**면 됨
>
> **unsigned**형 X
>
> 관련 헤더 파일 : ```float.h``` 
>



## 8. 열거형(enum)

> * 열거형은 여러 문자열을 하나의 그룹으로 만들어 놓고, 각각 번호를 붙여서 그 키워드가 곧 값이 되는 상수와도 비슷한 존재



## 9. 변수 선언

> * 변수 선언은 반드시 블럭의 시작에서 한다.
> * 코드 중간에 사용하는 변수 → 블록 시작에서 선언만 하고 뒤에 대입.



## 10. 연산자 (C에서 새로 만나는 연산자)

> * sizeof()
> * 역 참조 연산자 *
> * 주소 연산자 &
> * 구조체와 공용체 멤버 접근자 .과 →



### 10-1 sizeof() 연산자

>* 피연산자의 크기를 바이트로 반환해주는 연산자
>* 실행 중이 아닌 컴파일 도중에 크기를 찾음 (stack쪽에서 정확하게 배움.)
>* char형을 넣으면 반드시 1이 반환.
>* sizeof()연산자가 반환하는 값은 부호 없는 정수형의 상수로 **size_t**형



### 10-2 size_t

> * 부호 없는 정수형, But 실제 데이터형은 아님.
> * 단, 배열을 만들면 그 배열의 바이트 크기를 얻을 수 있다고 명시.
> * _t는 typedef를 했다는 **hint!!**
> * C99 표준에서 확실히 최소 16비트를 요구.
> * 보통은 unsigned int를 사용.
> * 용도 : 어떤 것의 크기를 나타내기 위해 사용
> * ex)  반복문이나 배열에 접근할 때 사용
>   * 반복문의 카운터 변수에 음수 필요가 없을 경우
>   * 배열의 경우 길이가 음수가 될 수 없으니까......
> * 배열의 경우, 함수 인자로 받을 경우 다른 결과 나옴.



### 10-3 역 참조 연산자	

> 

