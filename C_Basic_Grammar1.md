# C언어의 기본 문법 1

>* C는 절차적 언어(절차적 언어는 이해하기 쉬움)
>* 메뉴얼에 적혀 있는 내용을 순서대로 따라하는 느낌
>* 클래스 X
>* 함수
>* 모두 전역(global) 함수
>* 기본적으로 어디에서나 호출 가능
>* 변수
> * 함수 밖 선언 : 전역 변수
>* 함수 안 선언 : 지역(local) 변수



## 1. 자료형, unsigned와 signed

>* 정수형을 양수 전용으로 쓰고 싶을 때는 unsigned를 사용한다.
>
>* unsigned 자료형을 사용할 때는 출력 시 변환 문자 사용에 **주의!!**
>
>  * unsigned 자료형은 항상 양수만 저장하고 %u로 출력하기를 권장.
>
>* signed는 C/C++ 프로그램 언어에서 정수형 변수 중 부호를 갖는 변수를 선언한다. 
>
>* 정수형 중 음수는 2의 보수 체계를 사용, 이 키워드에 의해 부호를 사용할 수 있도록 변수 선언할 수 있다. 
>
>* **But**, 정수형의 변수에서 unsigned가 없으면 음수를 사용할 수 있는 부호를 갖는 정수형이 된다.   
>
>  따라서 프로그램에서는 이 키워드는 많이 사용은 하지 않는다.



## 2. char 형

> **char(character)** : **최소 8비트**인 정수형 처리 변수, 
>
> 부호형 변수 :  -128~127까지의 숫자를 취급. 
>
> >   **범위**
> >
> >   * 부호 없는 경우(unsigned) : 0~255
> >   * 보통 부호 있는 경우(signed) : -128~127    (**BUT**, 안전한 포팅을 위해선 -128이 아닌 -127 사용.)
> >   * 부호(unsigned/signed)를 생략할 경우 : signed
> >
> >   ```c
> >   char signed_char = -1;
> >   ```
>
> 부호가 있는 정수형 : 2의 보수 체계를 사용하여 +와 -로 나누어 숫자를 표현.  
>
> 아스키 코드 값은 기본적으로 8비트 이므로 이것은 8비트 정수형의 부분집합일 뿐이다. 따라서 문자 만이 아니라 8비트 정수형 연산도 가능하다. 
>
> ex ) 'A'를 'a'로 바꾸려면 정수형 연산으로 가능하다. 이때 역시 ALU을 통한 정수형 연산이 기계어 코드에 의해 계산 된다. 
>
> * **표준은 8비트 이상이라고만 정의.**
>
> **char** 가 몇 비트인지 찾는 방법
>
> ```c
> # include <limits.h>
> 
> int main(void)
> {
> 	char char_size = CHAR_BIT;
>     return 0;
> }
> ```
>
> ```<limits.h>```헤더를 include 한 뒤, ```CHAR_BIT```를 보면 몇 비트인지 확인 가능.
>
> **단**, 8비트 정수형으로 쓸 때 반드시 char 앞에 signed나 unsigned를 작성하는 게 좋음.



## 3. short형

> * 기본 정수형보다 짧음.
>
> * 메모리를 적게 쓰기 위해 사용.
> * **BUT**, int 대신 short를 사용할 경우 성능 느려질 가능성 有
>   1. 크기  : 표준에 따르면 **최소 16비트**, int의 크기 이상인 정수형
>   2. 범위 (포팅 문제 없는 값의 범위)
>      * 부호 없는 경우(unsigned) : 0~65535
>      * 부호 있는 경우(signed) : -32768~32767



## 4. int형

> int : 정수(integer)
>
> C언어의 타입 정의에 int형은 **"CPU의 레지스터와 동일한 크기를 가지는 타입"**으로 정의되어 있다.
>
> ```레지스터란?``` :  CPU내의 임시 기억 장소이며, 레지스터의 크기에 따라 CPU의 비트수를 정의한다.
>
> **즉, 레지스터가 16비트 : 16비트 컴퓨터 **
>
> ​                          **32비트 : 32비트 컴퓨터**
>
> * 즉,  int형은 CPU가 가장 효율적으로 다룰 수 있는 정수형으로 정의되어 있다.
>
>   *  그래서 int형의 실제 크기는 플랫폼에 따라 달라진다.
>   *  **32비트 운영체제**에서 int 는 **32비트**, **64비트 운영체제**에서 int형이 64비트(8바이트)가 될 것이다.
>
> * 특별한 경우가 아니면 정수형은 int를 사용
>
>   * int형은 연산의 기본 단위, 컴퓨터에서 가장 빠르게 연산.
>
> * 각 자료형의 크기는 컴파일러나 버전에 따라 다를 수 있으나 다음 기준에 따라 구현된다.
>
>   ```c
>   char <= short <= int <= long <= long long
>   ```
>
> * **리터럴(literal)** : 데이터 그 자체를 뜻함. (변수의 값이 변하지 않는 데이터**(메모리 위치 안의 값 )**)
>
>   * 'u' or 'U' : 부호 없는(unsigned) 수를 표현하는 접미사
>     * 부호 있는 수의 최댓값보다 큰 값을 unsigned int에 대입할 경우 'u' or 'U' 를 붙인다.
>     * 안 붙이면 경고 발생



## 5. long형

> * c언어에서 int와 long은 크기나 부호 여부가 동일
> * 따라서 표현할 수 있는 수의 범위도 완전히 동일한 것처럼 보임.
>   * **BUT**, 엄밀히 말하면 다른 타입이다.  
> * ```long형```은 그 크기가 4바이트로 고정, 어떤 플랫폼에서나 4바이트. 
> * **차이점** : int와 long이 동일한 크기를 가지는 것은 32비트 플랫폼에서 뿐이다.
> * 16비트에서는 다른 타입이고 64비트에서도 달라질 것.
> * long의 리터럴
>   * 'l' or 'L' : long 을 의미하는 접미사
>   * 'u' or 'U' : 부호 없는 수를 표현하는 접미사
>   * 두 접미사를 같이 쓸 수 있음 : unsigned long 이라는 의미가 됨
> * C 표준에 따른 long형의 크기 : 최소 32비트, int 이상



## 6. float형 

> * float는 **IEEE 754 Single**(32비트)
> * 표준에 따른 C의 float은 IEEE 754일수도 있고, 아닐 수도 있다.
> * 크기 : char (8비트) 이상이기만 하면 됨.
> * **unsigned**형 X
> * 표준 상관 X, 보통 안전하게 생각해도 되는 것
>   * 크기 : 32비트
>   * 범위 : IEEE 754 Single과 동일
> * 관련 헤더 파일 : ```float.h``` 



## 7. double형

>* double : IEEE 754 Double(64비트) **[컴파일러 구현에 따라 다름, IEEE 754 Double이라는 보장 X]**
>* 크기 : float 이상이면 됨.
>* **unsigned**형 X
>* 표준 상관 X, 보통 안전하게 생각해도 되는 것
> * 크기 : 64비트
> * 범위 : IEEE 754 Double과 동일
>* 관련 헤더 파일 : ```float.h``` 



### - long double

> * **생각보다 잘 안 쓰임!!**
>
> double보다 정밀도 ↑
>
> **double 이상의 크기**면 됨
>
> **unsigned**형 X
>
> 관련 헤더 파일 : ```float.h``` 



## 8. 열거형(enum)

> * 열거형은 여러 문자열을 하나의 그룹으로 만들어 놓고, 각각 번호를 붙여서 그 키워드가 곧 값이 되는 상수와도 비슷한 존재



## 9. 변수 선언

> * 변수 선언은 반드시 블럭의 시작에서 한다.
> * 코드 중간에 사용하는 변수 → 블록 시작에서 선언만 하고 뒤에 대입.



## 10. 연산자 (C에서 새로 만나는 연산자)

> * sizeof()
> * 역 참조 연산자 * 
> * 주소 연산자 &
> * 구조체와 공용체 멤버 접근자 .과 →



### 10-1 sizeof() 연산자

>* 피연산자의 크기를 바이트로 반환해주는 연산자
>* 실행 중이 아닌 컴파일 도중에 크기를 찾음 (stack쪽에서 정확하게 배움.)
>* char형을 넣으면 반드시 1이 반환.
>* sizeof()연산자가 반환하는 값은 부호 없는 정수형의 상수로 **size_t**형



### 10-2 size_t

> * 부호 없는 정수형, But 실제 데이터형은 아님.
> * 단, 배열을 만들면 그 배열의 바이트 크기를 얻을 수 있다고 명시.
> * _t는 typedef를 했다는 **hint!!**
> * C99 표준에서 확실히 최소 16비트를 요구.
> * 보통은 unsigned int를 사용.
> * 용도 : 어떤 것의 크기를 나타내기 위해 사용.
> * size_t를 쓰기에 적합한 경우: **배열의 색인으로 사용할 때.**
> * ex)  반복문이나 배열에 접근할 때 사용
>   * 반복문의 카운터 변수에 음수 필요가 없을 경우
>   * 배열의 경우 길이가 음수가 될 수 없으니까......
> * 배열의 경우, 함수 인자로 받을 경우 다른 결과 나옴.



### 10-3 구조체/공용체 멤버 접근자

> * . 연산자
>   * C에는 클래스 X, 따라서 함수 호출에 쓸 수 없다.
>   * 구조체,공용체 있으니 그들의 멤버변수에 접근할 때 사용
> * → 연산자
>   * 2개의 연산자 ' . ' 와 ' * '를 합친 것
>   * 구조체,공용체 있으니 그들의 멤버변수에 접근할 때 사용



### 10-4 비교 연산자,논리 연산자,조건 연산자

>* 비교 연산자
>
> * ==
>
> * !=
>
> * < >
>
> * <=
>
> * '  >=   ' (' '한 이유는 >= 하면 세로줄이 쳐지기 때문에....)
>
>* 논리 연산자
>
> * &&
>
> * ||
>
> * !
>
>* 조건(conditional) 연산자
>
> * 삼항 연산자(ternary operator)라 불림
>
>   ```c
>   int num1 = 13;
>   int num2 = 67;
>   int min  = num1 < num2 ? num1 : num2;
>   ```



### 10-5 switch/case문

> * case에 사용 가능한 데이터형 : int, char ,enum 만 가능 (정수형)
> * 의도를 가지고 **'break'** 를 사용하지 않을 경우
>   * /* intentional fallthrough */  주석을 반드시 적는다!!
> * case 레이블은 반드시 상수만!



### 10-6 for문, while문

> * for문
>   * for문의 초기화 코드에 size_t=0 못 씀. 
>   * for(size_t=0;i<9;++i) → 컴파일 오류!!
> * while문은 C#에서 while문과 동일하다.

