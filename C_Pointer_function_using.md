# 포인터 함수와 사용하기

### 1. 포인터 변수를 선언하는 방법

> 포인터 변수를 선언하는 방법
>
> * 선언하려면 자료형 뒤에 별표(*)를 붙임
>   * ex) int* , char* ,float*
>   * 별표 왼쪽 자료형은 그 메모리 주소로 가면 저장되어 있는 자료형이다.

### 2. 포인터 변수를 부르는 법

> 포인터 변수를 부르는 법
>
> * 대부분은 int num을 int형 num 이라 부르지만, 
>
>   영어로는 int 로의 포인터라고 하기 때문에 영어의 표현 방식을 숙지해놓기

### 3. 포인터 변수의 실제 메모리 뷰

> * 리틀 엔디언 : 데이터가 끝나는 마지막 단위가 가장 작은 메모리 주소에 위치하는 저장 순서

### 4. 포인터에 저장된 주소도 바꿀 수 있나요?

> * 포인터도 변수이기 때문에 포인터에 저장한 값도 변경 가능하다.
> * 다른 주소로 바꾸기 가능

### 5. 역 참조 연산자 *

> * 역 참조
>
>   * 주소로 직접 가서 그곳에 저장되어 있는 값에 접근
>   * 참조의 반대
>
> * ```참조란?``` 
> * 포인터가 이미 하고 있는 일
>   * 변수의 값을 직접 가져다 쓰는 것이 아닌 그 값이 어디에 있는지 가리키고 있는 것을 참조라 한다.

### 6. 값에 의한 전달 or 참조에 의한 전달?

> * 원본이 바뀌냐 안바뀌냐가 제일 중요
> * 참조에 의한 전달이라 하는게 낫다.

### 7. 포인터와 함수 반환 값

> * 포인터도 변수이므로 함수 반환값으로 사용 가능
>
> * 함수의 지역 변수는 스택에 저장됨
>
> * 함수 호출 끝  => 지역 변수 사라짐
>   * 주소는 남아있지만, 그 스택 프레임 자체가 유효하지 않다. 그래서 예측하지 못한 결과가 발생할 수도 있다.
> * 포인터를 반환? When?
>   * 도우미 함수 안에 생성한 변수를 다른 함수에서 사용하는 경우
>     * 단, 일반 지역 변수면 X (함수 호출이 끝나면 스택에서 사라진다.)
>   * 함수 안에서 대용량의 데이터를 생성하고 그걸 반환할 경우
>     * 데이터를 스택 메모리가 아닌 힙 메모리에 생성됨.

### 8. 댕글링 포인터(dangling pointer)

> * 실제 가리키는 대상이 없는 포인터를 **댕글링 포인터**라 한다.

### 9. 배열 속 각 요소의 위치 계산

> * 첫 번째 요소의 주소,자료형의 크기 안다
>   * 두 번째 요소의 주소 알아낼 수 있다.
> * 두 번째 요소 주소 = 첫 번째 요소 주소 + 자료형의 크기(바이트)
> * 세 번째 요소 주소 = 두 번째 요소 주소 + 자료형의 크기(바이트)
> * 포인터에 정수를 더한다는 건 바이트를 더한다는게 아닌 메모리 주소 위치를 다음 위치로 옮기는 것이다.

### *  정리

> C에서 포인터에 들어가는 값은 주소
>
> * 주소를 얻는 방법
>
> 1. 주소 연산자(&)
> 2. 배열의 이름 : 배열의 이름은 배열의 시작 주소를 알려준다.
>
> 포인터에 정수를 더하면 주소 이동
>
> * 포인터에 정수 n을 더하거나 빼면 "sizeof(자료형)*n"만큼 메모리 주소 이동



### 10. 두 주소 간의 사칙연산

> 뺄셈을 제외한 사칙연산은 모두 지원 X
>
> * 뺄셈 경우  두 주소 사이에 들어갈 수 있는 데이터 수를 반환한다.
>   * 포인터가 아닌 정수를 반환
> * 배열의 첫 번째 및 마지막 요소의 주소 알면 배열의 크기 구하기 가능.



### 11. 포인터와 배열의 차이

> 문자열 초기화
>
> * 문자열이 끝나는 지점을 알려주기 위해 널 문자라고 하는 특별한 문자를 항상 맨 마지막에 넣는다.
> * 널 문자 : 값은 0, '\0'
>   * 백 슬래시와 0을 합쳐서 표현
> * 함수 안에서 사용하면 스택 메모리에 저장된다.
> * 스택에 저장된 문자열은 수정해도 괜찮다. 
>   * But, 데이터 섹션에 저장된 문자열은 수정할 경우 크래시가 날 수도 있다.
> * 포인터 변수에 값을 대입할 수 있으나 배열 변수에는 X
> * 포인터는 산술 연산 가능, **배열은 불가능**
> * 배열의 주소 증가 or 감소하고 싶다
>   * 포인터에 배열의 주소를 대입, 후에 그 포인터 변수를 증가/감소하면 됨
> * 배열에 메모리 주소를 저장할 수 없다.
> * 배열에 전위 증가 연산자 사용할 수 없다.