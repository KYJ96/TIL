# C 스타일 문자열, 출력

## 1. 문자열의 표현과 길이

> * 문자열의 길이는 정해져 있지 않다.
>
> * ```문자열이란?```
>
>   여러 가지 글자(문자)가 모인 것, 공백조차 글자임.
>
> * 여러 개의 문자를 표현하려면?
>
>   * 배열
>
> * 배열의 길이가 배열과 같이 저장이 안되기 때문에, 프로그래머가 그 길이를 따로 기억하고 있어야 한다.



### 1-1 문자열 길이 문제 해결방법

> 1. 길이를 배열 첫 위치에 저장
>    * 첫 메모리 위치에 문자열 길이 저장
>    * 실제 문자열이 뒤에 따라오게 함
>    * 길이는 **int**로 저장하고 그 뒤에 char로 문자들을 저장
>
> * 1번의 장점 : 첫 주소를 보는 것만으로도 총 글자 수가 몇인지 파악 가능
> * 1번의 단점 : 순수 C 코드로 이것을 어떻게 작성해야 할지 애매함.
>
> 2. 문자열이 끝나는 위치를 표시
>
>    * 그냥 char []만 쓰되 그 문자열이 끝나는 위치에 특수한 문자 둘 것.
>
>      * 배열에서 값을 찾을 수 없을 때 존재할 수 없는 색인 -1을 반환하는 방식과 동일.
>
>    * 특수한 문자
>
>      * 제어 문자(0~31,127)
>
>      * 그 중에 하나가 널 문자(널 포인터와 다름)
>
>        
>
>    ```c
>    		char num_char = '\0';
>    ```
>
> * 0 : 숫자 0
> * \ : 이스케이프 문자
> * 가독성을 위해 '\0'으로 작성
> * **언제나 배열에 널 문자도 있다는 것을 잊지 말기!!**  



## 2. C 스타일 문자열 장단점

> * 장점
>   * 가장 최소한의 메모리
>   * 한 가지 데이터형으로 문자열과 길이를 표현
> * 단점
>   * 어떤 문자열의 길이를 알려면 배열을 끝까지 읽어 나가야 한다.
> * 안전하지 않을 수도 있다.
>   * 외부에서 들어오는 문자열을 읽을 때 조심해서 읽어야 함.
>   * 무엇이든 소유하지 않은 메모리 위치에 접근하는 건 매우 위험한 일이다.



## 3. 문자열 길이 구하기

> * 개념(문자열 길이 구하기)
>
> 1. char 배열의 요소를 처음부터 차례대로 읽기
> 2. 널 문자를 만나면 멈추기
> 3. 여태까지 총 몇 개의 char를 방문했는지 그 카운터를 반환
> 4. 배열의 길이는 문자열의 길이보다 1이 크다. (Null character를 넣어야 하므로)



## 두 문자열의 비교

> ```c
>                compare_string(const char* str0, const char* str1);
> ```
>
> * 매개변수 : 두 문자열 포인터
>
> * 사전식 순서로 어떤 문자의 아스키코드가 더 작냐/같냐/크냐 판별
>
>   * 단순히 같다/틀리다를 비교하는 것이 아니다.
>
>   
>
> * 사전식 순서(아스키 코드(10진수))
>
>   * ABCD < ABCE
>   * abcd > ABCD
>
> * **compare_string()** 의 반환값
>
>   * 같다 : 0
>   * 좌항이 작다 : <0
>   * 좌항이 크다 : >0
>   * 음수도 반환하므로 반환형은 int
>
>   ```c
>   int compare_string(const char* str0, const char* str1);
>   ```



## 문자열 복사,strcpy(),strncpy()

>* strcpy**(string copy)** 
>
>* ```c
> char* strcpy(char* dest, const char* src);
> ```
> ```
>
> ```
>
>```
>
>```
>
>```
>* <string.h> 안에 있다.
>* 반환값 char* : dest를 반환
>* src와 dest의 크기를 확실하게 통제 가능하다면 안전
>* strncpy 사용하면 비교적 안전
>* 프로그래머는 언제나 이렇게 코드 한 줄 추가
>strncpy(dest, src, DEST_SIZE);
>dest[DEST_SIZE - 1]= '\0'; /* 추가 */
>```
>
>
>
>```c
>			strcpy()                               strncpy()
>      위험할 수 있는 함수                       strcpy()보다 안전
>      dest 크기 < src 크기                        덜 빠르다
>      잘못된 메모리 쓰기 발생           덜 빠른 이유 : dest의 남은 요소를 0으로 채움
> 두 크기를 확실히 통제 가능 => 안전              count보다 src가 길 경우
>                                          => 다 복사하고 널 문자 X
>          								프로그래머가 널 문자 넣어줘야 한다.
>
>```
>
>```
>
>```
>
>```



## 문자열 합치기, strcat(), strncat()

> * strcat()
>   1. 위험할 수 있는 function
>   2. dest의 남아있는 공간 < src의 크기
>      * undefined result 발생
>   3. 두 크기를 확실히 통제 가능 => 안전
> * strncat()
>   1. 위 함수보다 안전
>      * count로 얼마나 붙일지 제어 가능
>   2. dest의 남아있는 공간 < count의 크기
>      * undefined result 발생



## 문자열 찾기

> * 문자열 속에서 문자열 찾기
>
>   ```c
>   char* strstr(const char* str, const char* substr);
>   ```
>
>   * <string.h> 안에 있다.
>   * 반환값 : char 포인터
>     * substr이 str에 있다 : 해당 substr이 시작하는 주소
>     * substr이 str에 없다 : NULL(널 포인터)



## 문자열 토큰화

> * 

