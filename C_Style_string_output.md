# C 스타일 문자열, 출력

## 1. 문자열의 표현과 길이

> * 문자열의 길이는 정해져 있지 않다.
>
> * ```문자열이란?```
>
>   여러 가지 글자(문자)가 모인 것, 공백조차 글자임.
>
> * 여러 개의 문자를 표현하려면?
>
>   * 배열
>
> * 배열의 길이가 배열과 같이 저장이 안되기 때문에, 프로그래머가 그 길이를 따로 기억하고 있어야 한다.



### 문자열 길이 문제 해결방법

> 1. 길이를 배열 첫 위치에 저장
>    * 첫 메모리 위치에 문자열 길이 저장
>    * 실제 문자열이 뒤에 따라오게 함
>    * 길이는 **int**로 저장하고 그 뒤에 char로 문자들을 저장
>
> * 1번의 장점 : 첫 주소를 보는 것만으로도 총 글자 수가 몇인지 파악 가능
> * 1번의 단점 : 순수 C 코드로 이것을 어떻게 작성해야 할지 애매함.
>
> 2. 문자열이 끝나는 위치를 표시
>
>    * 그냥 char []만 쓰되 그 문자열이 끝나는 위치에 특수한 문자 둘 것.
>
>      * 배열에서 값을 찾을 수 없을 때 존재할 수 없는 색인 -1을 반환하는 방식과 동일.
>
>    * 특수한 문자
>
>      * 제어 문자(0~31,127)
>
>      * 그 중에 하나가 널 문자(널 포인터와 다름)
>
>    
>```c
> char num_char = '\0';
> ```
> 
>* 0 : 숫자 0
> * \ : 이스케이프 문자
> * 가독성을 위해 '\0'으로 작성
> * **언제나 배열에 널 문자도 있다는 것을 잊지 말기!!**  



## 2. C 스타일 문자열 장단점

> * 장점
>   * 가장 최소한의 메모리
>   * 한 가지 데이터형으로 문자열과 길이를 표현
> * 단점
>   * 어떤 문자열의 길이를 알려면 배열을 끝까지 읽어 나가야 한다.
> * 안전하지 않을 수도 있다.
>   * 외부에서 들어오는 문자열을 읽을 때 조심해서 읽어야 함.
>   * 무엇이든 소유하지 않은 메모리 위치에 접근하는 건 매우 위험한 일이다.



## 3. 문자열 길이 구하기

> * 개념(문자열 길이 구하기)
>
> 1. char 배열의 요소를 처음부터 차례대로 읽기
> 2. 널 문자를 만나면 멈추기
> 3. 여태까지 총 몇 개의 char를 방문했는지 그 카운터를 반환
> 4. 배열의 길이는 문자열의 길이보다 1이 크다. (Null character를 넣어야 하므로)



## 4. 두 문자열의 비교

> ```c
>                compare_string(const char* str0, const char* str1);
> ```
>
> * 매개변수 : 두 문자열 포인터
>
> * 사전식 순서로 어떤 문자의 아스키코드가 더 작냐/같냐/크냐 판별
>
>   * 단순히 같다/틀리다를 비교하는 것이 아니다.
>
>   
>
> * 사전식 순서(아스키 코드(10진수))
>
>   * ABCD < ABCE
>   * abcd > ABCD
>
> * **compare_string()** 의 반환값
>
>   * 같다 : 0
>   * 좌항이 작다 : <0
>   * 좌항이 크다 : >0
>   * 음수도 반환하므로 반환형은 int
>
>   ```c
>   int compare_string(const char* str0, const char* str1);
>   ```



### 문자열 복사,strcpy(),strncpy()

>* char* strcpy (char* dest, const char* src);
>    1. <string.h> 안에 있다.
>
>    2. 반환값 **char*** : dest를 반환
>    3. src와 dest의 크기를 확실하게 통제 가능하다면 안전
>    4. strncpy 사용하면 비교적 안전
>
>    5. 프로그래머는 언제나 이렇게 코드 한 줄 추가
>
>       strncpy(dest, src, DEST_SIZE);
>       dest[DEST_SIZE - 1]= '\0'; /* 추가 */
>
>* **strcpy()**
>    1. 위험할 수 있는 함수
>    2. dest 크기 < src 크기
>       - 잘못된 메모리 쓰기 발생
>       - 두 크기를 확실히 통제 가능 => 안전
>
>* **strncpy()**
>    1. strcpy()보다 안전
>    2. 덜 빠르다
>       - 덜 빠른 이유 : dest의 남은 요소를 0으로 채움
>
>    3. count보다 src가 길 경우
>
>       - 다 복사하고 널 문자 X
>
>       - 프로그래머가 널 문자 넣어줘야 한다.



### 문자열 합치기, strcat(), strncat()

> * **strcat()**
>   1. 위험할 수 있는 function
>   2. dest의 남아있는 공간 < src의 크기
>      * undefined result 발생
>   3. 두 크기를 확실히 통제 가능 => 안전
> * **strncat()**
>   1. 위 함수보다 안전
>      * count로 얼마나 붙일지 제어 가능
>   2. dest의 남아있는 공간 < count의 크기
>      * undefined result 발생



## 5. 문자열 찾기

> * 문자열 속에서 문자열 찾기
>
>   ```c
>   char* strstr(const char* str, const char* substr);
>   ```
>
>   * <string.h> 안에 있다.
>   * 반환값 : char 포인터
>     * substr이 str에 있다 : 해당 substr이 시작하는 주소
>     * substr이 str에 없다 : NULL(널 포인터)



## 6. 문자열 토큰화

> ```c
> char msg[] = "Hi, there. Hello. Bye";
> const char delims[]=",.";
> 
> char* token = strtok(msg,delims);
> while(token!=NULL){
>     printf("%s\n",token);
>     token=strtok(NULL, delims);
> }
> ```
>
> * 토큰화를 시작하려면 문자열(msg)를 strtok()에 삽입
> * 그 msg의 다음 토큰을 구하려면 대신 **NULL**
> * 더 이상 토큰이 없다 => strtok()은 NULL을 반환
> * 토큰화하는 문자열은 const가 아님(원본이 바뀜)
> * 함수 매개변수로 NULL이 들어올 때 그전에 받았던 msg를 사용하므로 어디에 저장되어 있어야 할까?
>   * 함수 내 정적 변수가 제일 적합



## 7. C 문자열 함수들의 특징

> * 꽤 많은 함수들이 문자열을 절대 변경 X
>   * 매개변수에 * 붙는다.
>     * ex) const char*
> * 문자열을 변경하더라도도, 원본은 변경 안 하려 함
>   * 사본만 변경!
>   * 예외 : strtok()
>     * 원본을 지키는 방법은 호출하는 함수에서 사본을 만든 뒤 strtok()을 호출해야 한다.
> * 절대 새로운 문자열(연속된 char 메모리)을 만들어 주지 않음.



## 8. 출력, 서식 지정(formatted) 출력, 서식 문자열(format string)

> * 출력을 논할 때 가장 기본이 되는 함수
> * 종류
>   1. ```printf()``` : 콘솔창에 출력
>   2. ```fprintf()``` : 스트림에 출력
>   3. ```sprintf()``` :문자열에 출력
>
> * 2번과 3번은 1번 작동법과 동일
> * 유일하게 다른 점: 첫 번째 매개변수로 출력할 곳을 넣어주는것
> * 서식 문자열
>   - %로 시작하는 문자열
>   - 소수점 이하 자리수, 자릿수 정렬, 어떤 데이터(숫자,문자)를 출력할지 등을 알려주는 문자열



### 8-1 일반적인 서식 문자열 형식, 서식 지정자(format specifier)

> ```%[플래그][너비][.숫자 정밀도 | . 문자열 최소/최대 출력 개수][길이]서식 지정자```
>
> * 일반적으로 % 뒤에 최대 4개 지정자 가능
> * 아래의 순서들을 지켜가면서 작성
>   1. 플래그(선택)
>   2. 너비 (선택)
>   3. 정밀도 (선택)
>      * 숫자 정밀도
>      * 문자열 최소/최대 출력 개수
>   4. 길이(선택)
>   5. 서식 지정자(필수)



### 8-2 서식 문자열이 필요한 이유

> * 일단 오버로딩 X  =>  printf(int), printf(char) 불가능
> * 임시 문자열 등 자동으로 생성 X
> * 

