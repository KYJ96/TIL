# C언어의 기본 문법 2, 빌드 단계



## 1. 함수

> * C의 함수 선언은 C#과 거의 동일
> * 접근 제어자가 없다.
> * 기본적으로 모두 전역(global)함수
> * C의 함수는 어디서든 호출할 수 있다.
>   * 다만, 이걸 제한할 수 있는 키워드가 있다.
> * C는 언제나 위에서 아래로 코드를 읽음.
> * 컴파일이 오류나지 않기 위한 **Solution~~**
>   * 호출 전에 함수의 정의를 위치시키면 아무 문제 없다.





### 1-1 함수 선언(function declaration)

> * 함수의 구현체 없이 함수 원형만 선언해 주는 것
>
> > **함수 원형**은 아래의 번호들을 명시한다.
> >
> > 1. 함수의 이름
> > 2. 반환형
> > 3. 매개변수들의 자료형
>
> 함수 선언은 언제나 하는 것이 좋다
>
> * C99 표준부터는 int 가정을 하지 않는다.
>   * 그러나 어떤 컴파일러는 경고만, 컴파일은 허용 할 수도 있다.
>   * 모든 컴파일러가 그렇단 보장이 없기 때문에 반드시 선언.





### 1-2 함수 매개변수 평가 순서, 피연산자 평가 순서

> * 함수 매개변수의 평가 순서는 지정되어 있지 않음.
> * 누가 먼저 호출되는지는 컴파일러에 따라 다르다.



> * 명시되지 않은 피연산자 평가 순서에서
>   * 한 줄에 있는 함수 호출 순서에 의존해서 코드를 작성하지 말자!!
>   * 해결 방법 : 두 함수를 두 줄에 따로 호출.
> * 기본적으로 한 줄에서 동일한 변수를 여러 번 바꾸면 위험하다.
>   * 함수 매개변수의 평가 순서는 컴파일러마다 다를 수 있다
>   * 한 함수의 매개변수들이 동일한 변수를 수정할 경우, 결과가 정의되지 않음. (undefined behavior)



### 1-3 연산자 우선순위와 평가 순서 

> 연산자 우선순위와 평가 순서는 **서로 아무 연관이 없음**.
>
> ```c
> int i=0;
> int j=0;
> int k=0;
> 
> if(++i || ++j && ++k)
> {
>  printf("true\n");
> }
> printf("%d %d %d\n",i,j,k);
> ```
>
> 
>
> * 연산자의 우선 순위에 따라 && 부분을 묶는 것 맞다.
>
>   * BUT, 왼쪽부터 차례대로 연산한다.
>
>   ++i 를 먼저 연산하면 1 참이 된다.
>
> O or O 는 둘 중에 하나만 참이 되면 되기 때문에 이미 ++i가 참이므로 오른쪽 피연산자 검사할 필요가 없다. 
>
> 이러한 경우를 ``short circuit`` 평가라고 한다. 



```short circuit rule이란?``` 

좌항만으로 &&와 || 연산 결과를 판별하는 기능

```c
a=0;
b=1;
if(a&&b) // a만 검사하고 빠져나온다.
if(a||b) // b까지 검사해야 논리 연산의 결과값을 알 수 있다.    
```



> 위의 코드와 비슷하게 i 부분을 i++로 변경한다면,
>
> 먼저 연산하면 0 (거짓)이 되기 때문에 오른쪽 연산을 하게 된다.
>
> 뒷 부분 ++j && ++k 부분을 연산하면 1&&1이므로 참이 된다.
>
> 거짓 or 참을 연산하게 되면 참이 되므로 최종적으로 i=1,j=1,k=1이 된다.



> 한 줄에 있는 피연산자들은 기본적으로 **평가 순서가 보장 안된다**고 생각하면 된다!!



### 1-4 범위 (scope)

> * 4가지 범위
>   * 블록 범위 
>   * 파일 범위
>   * 함수 범위
>   * 함수 선언 범위
>
> * 파일 범위
>   * 어떤 블록이나 매개변수 목록에도 안 속하고 파일 안에 있는 것
> * 함수 범위
>   * ex) 레이블(label)
>   * goto 문에서 사용.
> * 함수 선언 범위
>   * 함수 선언의 매개변수 목록에 있는 것 → 그 목록 안에서 접근 가능.
>   * 많이 쓸 일은 없다.



### 1-5 const 키워드

> * 이름 달린 상수를 만들어 주기 좋다.
> * 정말 값 변경이 필요한 변수에만 const를 생략.
> * In principle, 언어의 기본동작이 바뀌어야 함.
>   * 아무것도 안 붙이면 const



### 1-6 goto 문

> ```c
> goto <label_name>;
> ...
> <label_name>:    
> ```
>
> * ``goto``를 쓰면 같은 함수 내에 있는 레이블(label)로 점프.
> * goto 문은 악마인가?
>   * 코드가 꼬여 있어서 스파게티 코드라고 불린다.
>   * goto 없이 안쪽 for문에서 탈출하려면 많은 if문을 사용하게 됨.
> * 중간에 에러가 나면 이미 수행한 작업을 되돌리는데 편함.
> * goto문은 언제나 전방 (아래쪽)으로만 점프할 것
>   * 후방 (위)으로 점프하면 스파게티처럼 꼬인다.
> * 내포된 루프에서 빠져나올 때 자유롭게 쓸 것.
> * 한 함수 안에 있는 여러 개의 조건문이 공통된 코드를 실행해야 할 때도 써도 됨.
>   * ex) 함수 마지막에 성공/오류 조건 처리
> * 보기 좋게 하기 위해 goto문은 언제나 아래쪽에 위치한 레이블로만 점프.



## 2. 배열

### 2-1 스택 메모리

> * 스택 메모리의 크기 : 프로그램 빌드 시에 결정됨.
>
> * 스택 메모리의 위치 : 실행 시에 결정됨.
>
> * 개념 : 함수가 호출될 때마다 그 함수에서 필요한 공간을 스택에서 떼어줬다가,
>
>   ​		   그 함수가 반환하면 그냥 흔들어 지워버리는 개념 
>
>   * 실제로 지우지는 않는다.
>
> * new로 만든 데이터 : 힙(heap) 메모리에 할당됨
>
>   * 이러한 경우 메모리에 구멍이 슝슝 뚫릴 수 있음.
>   
> * 스택은 큰 주소에서 작은 주소로 쌓임.



### 2-2 매개변수 배열의 길이, 배열 요소의 초기값

> Best Practice : 배열의 모든 값을 0으로
>
> * 배열의 모든 값을 0으로 초기화 하는 방법은 0뒤에 쉼표를 찍으면 된다.
>   * ex)  int nums[10]={ 0,  };
> * 초기화 안된 지역변수를 모른채 사용할 수 있기 때문에 위험하다.
> * 버퍼 오버플로도 가능
> * ```버퍼 오버플로란?``` 
>   * 메모리를 다루는 데에 오류가 발생하여 잘못된 동작을 하는 프로그램 취약점이다.
>   * 컴퓨터 보안과 프로그래밍에서는 프로세스가 데이터를 버퍼에 저장할 때 프로그래머가 지정한 곳 바깥에 저장하는 것을 의미



### 2-3 다차원 배열

> * 2차원 or 3차원 배열 같은 것
> * 2차원 배열 : int [] []



### 2-4 소스코드에서 실행파일까지, C 프로그램의 빌드 과정

> * ```빌드(build)```란?
>   * 읽기 쉬운 소스코드를 기계어 명령어로 변환하는 과정
>   * 명령어들을 모아 기계에서 실행 가능한 실행파일로 만드는 과정
> * 빌드 단계
>   1. 전처리(preprocessing)
>   2. 컴파일(compilation)
>   3. 어셈블(assembling)
>   4. 링크(linking)
> * 1,2,3 을 합쳐서 컴파일이라고도 부른다.



### 2-5 .h와 .c 파일

> * .c 파일
>   * 실제 프로그램을 돌게 하는 로직 코드를 저장해 두는 파일
>   * 내용물
>     * 함수 정의(=함수 구현)
>     * 전역 변수 등
>     * 매크로
> * .h 파일
>   * 여러 소스코드 파일에 공통적으로 필요한 것들을 저장해 두는 파일
>   * 내용물
>     * 함수 선언
>     * 매크로
>     * extern 변수 선언 등



### 2-6 헤더파일이 필요한 이유

> * 헤더 파일을 사용하면 함수 선언을 여러 C파일들과 공유 가능



### 2-7 #include <> 와 #include " "

> * #include <>
>   * <>는 시스템 경로에서만 헤더 파일을 검색한다.
>     * 보통 검파일러가 제공하는 시스템 헤더 파일을 include 할 때 사용.
> * #include " "
>   * " "는 현재 작업 중인 디렉터리에서 헤더 파일을 먼저 검색한 뒤 없으면 시스템 경로를 검색
>     * 개발자가 구현한 헤더 파일들을 include 할 때 사용.



### 2-8 트랜슬레이션 유닛을 보는 방법

> clang 컴파일 중 -E 플래그를 넣는다.
>
> ex) **clang -std=c89 -W -Wall -pedantic-errors -E adder.c** 
>
> * 파일로 저장하려면 출력 리디렉션(output redirection) 쓰기
>   * ex) 위 예시 + **adder.pre** 



### 2-9 빌드 과정: 전처리 단계

> 1. 전처리 단계
>    * 전처리기라는 별도의 프로그램이 담당.
>      1. 주석 제거
>      2. 매크로 ~~복붙~~  확장
>      3. 인클루드 파일들을 ~~복붙~~ 확장
>      4. 출력 : 확장된 소스코드



### 2-10 빌드 과정 : 컴파일 단계

> * 컴파일러가 컴파일을 담당한다.
> * 출력 : 어셈블리어 코드
> * 어셈블리어 코드 : 아직 정의를 모르는 심볼 사용 가능
>   * 심볼(symbol) : 함수나 변수의 이름 등
>   * 헤더를 통한 선언만으로 컴파일이 가능한 이유다.
> * 컴파일러가 어떤 함수나 변수의 정의를 못 찾을 경우, 구멍으로 남겨놓은다음 그 구멍을 메꾸는것을 링크 단계가 해준다.



### 2-11 빌드 과정 : 어셈블 단계

> 어셈블러(assembler)라는 프로그램이 담당해줌.
>
> * 오브젝트 코드
>   * 기계가 곧바로 이해 가능한 기계코드
>   * 기계어라고 불림
>   * 이진코드
>   * 어셈블리어코드와 같이 여전히 메꿔야 하는 구멍이 있음.



### 2-12 빌드 과정 : 링크 단계

> 링커(linker)라는 프로그램이 담당.
>
> * 처리과정
>   1. 링커는 모든 오브젝트 코드들을 모아 구멍을 메꾼 후 실행파일로 저장
>   2. 어셈블리 코드에 레이블 ex) ...add
>   3. 링커가 오브젝트 파일을 다 모아 하나의 이진 파일로 만들다가 & 함수의 위치를 기억하다가
>   4. 함수를 호출하려는 코드를 만나면 실행위치에 아까 그 위치로 점프하는 코드를 넣어줌.
>   5. 여전히 구멍으로 남아 있다면 링커가 못 찾아서 링커 오류를 뱉는다. 
>   6. 출력 : 최종파일 (.exe,.out)




