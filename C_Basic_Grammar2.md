# C언어의 기본 문법 2, 빌드 단계



## 1. 함수

> * C의 함수 선언은 C#과 거의 동일
> * 접근 제어자가 없다.
> * 기본적으로 모두 전역(global)함수
> * C의 함수는 어디서든 호출할 수 있다.
>   * 다만, 이걸 제한할 수 있는 키워드가 있다.
> * C는 언제나 위에서 아래로 코드를 읽음.
> * 컴파일이 오류나지 않기 위한 **Solution~~**
>   * 호출 전에 함수의 정의를 위치시키면 아무 문제 없다.





### 1-1 함수 선언(function declaration)

> * 함수의 구현체 없이 함수 원형만 선언해 주는 것
>
> > **함수 원형**은 아래의 번호들을 명시한다.
> >
> > 1. 함수의 이름
> > 2. 반환형
> > 3. 매개변수들의 자료형
>
> 함수 선언은 언제나 하는 것이 좋다
>
> * C99 표준부터는 int 가정을 하지 않는다.
>   * 그러나 어떤 컴파일러는 경고만, 컴파일은 허용 할 수도 있다.
>   * 모든 컴파일러가 그렇단 보장이 없기 때문에 반드시 선언.





### 1-2 함수 매개변수 평가 순서, 피연산자 평가 순서

> * 함수 매개변수의 평가 순서는 지정되어 있지 않음.
> * 누가 먼저 호출되는지는 컴파일러에 따라 다르다.



> * 명시되지 않은 피연산자 평가 순서에서
>   * 한 줄에 있는 함수 호출 순서에 의존해서 코드를 작성하지 말자!!
>   * 해결 방법 : 두 함수를 두 줄에 따로 호출.
> * 기본적으로 한 줄에서 동일한 변수를 여러 번 바꾸면 위험하다.
>   * 함수 매개변수의 평가 순서는 컴파일러마다 다를 수 있다
>   * 한 함수의 매개변수들이 동일한 변수를 수정할 경우, 결과가 정의되지 않음. (undefined behavior)



### 1-3 연산자 우선순위와 평가 순서 

> 연산자 우선순위와 평가 순서는 **서로 아무 연관이 없음**.
>
> ```c
> int i=0;
> int j=0;
> int k=0;
> 
> if(++i || ++j && ++k)
> {
>  printf("true\n");
> }
> printf("%d %d %d\n",i,j,k);
> ```
>
> 
>
> * 연산자의 우선 순위에 따라 && 부분을 묶는 것 맞다.
>
>   * BUT, 왼쪽부터 차례대로 연산한다.
>
>   ++i 를 먼저 연산하면 1 참이 된다.
>
> O or O 는 둘 중에 하나만 참이 되면 되기 때문에 이미 ++i가 참이므로 오른쪽 피연산자 검사할 필요가 없다. 
>
> 이러한 경우를 ``short circuit`` 평가라고 한다. 



```short circuit rule이란?``` 

좌항만으로 &&와 || 연산 결과를 판별하는 기능

```c
a=0;
b=1;
if(a&&b) // a만 검사하고 빠져나온다.
if(a||b) // b까지 검사해야 논리 연산의 결과값을 알 수 있다.    
```



> 위의 코드와 비슷하게 i 부분을 i++로 변경한다면,
>
> 먼저 연산하면 0 (거짓)이 되기 때문에 오른쪽 연산을 하게 된다.
>
> 뒷 부분 ++j && ++k 부분을 연산하면 1&&1이므로 참이 된다.
>
> 거짓 or 참을 연산하게 되면 참이 되므로 최종적으로 i=1,j=1,k=1이 된다.



> 한 줄에 있는 피연산자들은 기본적으로 **평가 순서가 보장 안된다**고 생각하면 된다!!



### 1-4 범위 (scope)

> * 4가지 범위
>   * 블록 범위 
>   * 파일 범위
>   * 함수 범위
>   * 함수 선언 범위
>
> * 파일 범위
>   * 어떤 블록이나 매개변수 목록에도 안 속하고 파일 안에 있는 것
> * 함수 범위
>   * ex) 레이블(label)
>   * goto 문에서 사용.
> * 함수 선언 범위
>   * 함수 선언의 매개변수 목록에 있는 것 → 그 목록 안에서 접근 가능.
>   * 많이 쓸 일은 없다.



### 1-5 const 키워드

> * 이름 달린 상수를 만들어 주기 좋다.
> * 정말 값 변경이 필요한 변수에만 const를 생략.
> * In principle, 언어의 기본동작이 바뀌어야 함.
>   * 아무것도 안 붙이면 const



### 1-6 goto 문

> ```c
> goto <label_name>;
> ...
> <label_name>:    
> ```
>
> * ``goto``를 쓰면 같은 함수 내에 있는 레이블(label)로 점프.
> * goto 문은 악마인가?
>   * 코드가 꼬여 있어서 스파게티 코드라고 불린다.
>   * goto 없이 안쪽 for문에서 탈출하려면 많은 if문을 사용하게 됨.
> * 중간에 에러가 나면 이미 수행한 작업을 되돌리는데 편함.
> * goto문은 언제나 전방 (아래쪽)으로만 점프할 것
>   * 후방 (위)으로 점프하면 스파게티처럼 꼬인다.
> * 내포된 루프에서 빠져나올 때 자유롭게 쓸 것.
> * 한 함수 안에 있는 여러 개의 조건문이 공통된 코드를 실행해야 할 때도 써도 됨.
>   * ex) 함수 마지막에 성공/오류 조건 처리
> * 보기 좋게 하기 위해 goto문은 언제나 아래쪽에 위치한 레이블로만 점프.



## 2. 배열

### 2-1 스택 메모리

> * 스택 메모리의 크기 : 프로그램 빌드 시에 결정됨.
>
> * 스택 메모리의 위치 : 실행 시에 결정됨.
>
> * 개념 : 함수가 호출될 때마다 그 함수에서 필요한 공간을 스택에서 떼어줬다가,
>
>   ​		   그 함수가 반환하면 그냥 흔들어 지워버리는 개념 
>
>   * 실제로 지우지는 않는다.
>
> * new로 만든 데이터 : 힙(heap) 메모리에 할당됨
>
>   * 이러한 경우 메모리에 구멍이 슝슝 뚫릴 수 있음.
>   
> * 스택은 큰 주소에서 작은 주소로 쌓임.



### 2-2 매개변수 배열의 길이, 배열 요소의 초기값

> Best Practice : 배열의 모든 값을 0으로
>
> * 배열의 모든 값을 0으로 초기화 하는 방법은 0뒤에 쉼표를 찍으면 된다.
>   * ex)  int nums[10]={ 0,  };
> * 초기화 안된 지역변수를 모른채 사용할 수 있기 때문에 위험하다.
> * 버퍼 오버플로도 가능
> * ```버퍼 오버플로란?``` 
>   * 메모리를 다루는 데에 오류가 발생하여 잘못된 동작을 하는 프로그램 취약점이다.
>   * 컴퓨터 보안과 프로그래밍에서는 프로세스가 데이터를 버퍼에 저장할 때 프로그래머가 지정한 곳 바깥에 저장하는 것을 의미
> * 